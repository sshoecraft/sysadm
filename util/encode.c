
/* 
 * XXX  THIS IS NOT UUENC/DEC COMPATIBLE (deliberately)
*/

#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>

#include "encode.h"

/* XXX New tab as of 10/31/2011 - replace space with dash */
unsigned char etab[64] = {
	0x78,0x49,0x64,0x59,0x55,0x56,0x4d,0x75,
	0x47,0x4b,0x69,0x72,0x34,0x4f,0x6c,0x4a,
	0x5f,0x37,0x50,0x71,0x6b,0x35,0x42,0x61,
	0x30,0x4c,0x74,0x65,0x58,0x77,0x39,0x52,
	0x43,0x51,0x38,0x73,0x76,0x6e,0x48,0x41,
	0x45,0x57,0x63,0x68,0x79,0x46,0x67,0x62,
	0x36,0x31,0x32,0x70,0x2d,0x5a,0x6f,0x6a,
	0x54,0x33,0x66,0x44,0x6d,0x53,0x4e,0x7a,
	};
unsigned char dtab[128] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x34,0x00,0x00,
	0x18,0x31,0x32,0x39,0x0c,0x15,0x30,0x11,
	0x22,0x1e,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x27,0x16,0x20,0x3b,0x28,0x2d,0x08,
	0x26,0x01,0x0f,0x09,0x19,0x06,0x3e,0x0d,
	0x12,0x21,0x1f,0x3d,0x38,0x04,0x05,0x29,
	0x1c,0x03,0x35,0x00,0x00,0x00,0x00,0x10,
	0x00,0x17,0x2f,0x2a,0x02,0x1b,0x3a,0x2e,
	0x2b,0x0a,0x37,0x14,0x0e,0x3c,0x25,0x36,
	0x33,0x13,0x0b,0x23,0x1a,0x07,0x24,0x1d,
	0x00,0x2c,0x3f,0x00,0x00,0x00,0x00,0x00,
	};
#define ENC(c) etab[(c) & 0x3F]
#define DEC(c) dtab[(c) & 0x7F]

int encoder_init(struct encoder_context *ctx, encode_outfunc_t func, void *arg) {
	memset(ctx,0,sizeof(*ctx));
	ctx->omask = 1;
	ctx->func = func;
	ctx->arg = arg;

	return 0;
}

int encode_byte(void *arg, int ch) {
	struct encoder_context *ctx = arg;
	unsigned char imask;

	if (!ctx) {
		printf("%s: ctx is null!\n",__FUNCTION__);
		return 1;
	}
	if (!ctx->func) {
		printf("encode_byte: ctx->func is null!\n");
		return 1;
	}

//	printf("encode: ch: %d\n", ch);

#if 0
	if (ch < 0) {
//		printf("och: %x\n", ctx->och);
		if (ctx->omask != 1) ctx->func(ctx->arg,ENC(ctx->och));
//		ctx->func(ctx->arg,ch);
	} else {
#endif
		for(imask=1; imask; imask <<= 1) {
			if (ch & imask) ctx->och |= ctx->omask;
			ctx->omask <<= 1;
			if (ctx->omask == 0x40) {
				ctx->func(ctx->arg,ENC(ctx->och));
				ctx->och = 0;
				ctx->omask = 1;
			}
		}
//	}

	return 0;
}

void encode_end(struct encoder_context *ctx) {
	if (ctx->omask != 1) ctx->func(ctx->arg,ENC(ctx->och));
	ctx->och = 0;
	ctx->omask = 1;
}

int decode_byte(void *arg, int ch) {
	struct encoder_context *ctx = arg;
	unsigned char imask;
	unsigned char ich;

	if (!ctx) {
		printf("decode_byte: ctx is null!\n");
		return 1;
	}
	if (!ctx->func) {
		printf("decode_byte: ctx->func is null!\n");
		return 1;
	}

//	printf("decode: ch: %x\n", ch);

#if 0
	if (ch < 0) {
//		printf("decode: och: %x\n", ctx->och);
		if (ctx->omask != 1) ctx->func(ctx->arg,ENC(ctx->och));
//		ctx->func(ctx->arg,ch);
	} else {
#endif
		ich = DEC(ch);
		for(imask=1; imask < 0x40; imask <<= 1) {
			if (ich & imask) ctx->och |= ctx->omask;
			ctx->omask <<= 1;
			if (!ctx->omask) {
				ctx->func(ctx->arg,ctx->och);
				ctx->och = 0;
				ctx->omask = 1;
			}
		}
//	}

	return 0;
}

void decode_end(struct encoder_context *ctx) {
//printf("omask: %x\n", ctx->omask);
//	if (ctx->omask != 1) ctx->func(ctx->arg,ctx->och);
	ctx->och = 0;
	ctx->omask = 1;
}
