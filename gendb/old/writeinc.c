
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "gendb.h"

extern int opts;

int write_inc(TABLE *table,list funcs,char *prefix) {
	FILE *fp;
	COLUMN *field;
//	FUNCTION *func;
	char defname[32];
	char temp[128],temp2[10];
	register int offset,len,i;

	if (opts & OPT_DEBUG) printf("write_inc: opening file: %s.h\n",prefix);
	sprintf(temp,"%s.h",table->name);
	fp = fopen(temp,"w+");
	if (!fp) {
		oserr("unable to open inc file");
		return 1;
	}

	for(i=0; i < strlen(table->name); i++) temp[i] = toupper(table->name[i]);
	temp[i] = 0;
	sprintf(defname,"__%s_H", temp);

	fprintf(fp,"\n");
	fprintf(fp,"#ifndef %s\n", defname);
	fprintf(fp,"#define %s\n", defname);

	/* Write the comment */
	fprintf(fp,"\n");
	fprintf(fp,"/*\n");
	fprintf(fp,"*** this file is automatically generated - DO NOT MODIFY\n");
	fprintf(fp,"*/\n");

	/* Write out the structure definition */
	if (opts & OPT_DEBUG) printf("write_inc: writing structure def...\n");
	fprintf(fp,"\n");
	fprintf(fp,"/* Structure definition for the %s table */\n",
		table->name);
	fprintf(fp,"struct %s_record {\n",table->name);
	printf("count: %d\n", list_count(table->fields));
	list_reset(table->fields);
	while( (field = list_get_next(table->fields)) != 0) {
#if 0
		sprintf(temp,"\t%s ",typestr(1,field->type));
		strcat(temp,field->name);
//		dprintf("temp: %s\n", temp);
		if (field->len > 1) {
			strcat(temp,"[");
			sprintf(temp2,"%d",field->len);
			strcat(temp,temp2);
			strcat(temp,"];");
		}
		else
			strcat(temp,";");
#endif

		if (field->ptr)
			sprintf(temp,"\t%s %s[%d];", field->ctype, field->name, field->len);
		else
			sprintf(temp,"\t%s %s;", field->ctype, field->name);
#if 0
		if (field->type == FT_CHAR || field->type == FT_STRING) {
			sprintf(temp,"\tchar %s",field->name);
			if (field->len > 1) {
				strcat(temp,"[");
				sprintf(temp2,"%d",field->len);
				strcat(temp,temp2);
				strcat(temp,"];");
			}
			else
				strcat(temp,";");
		}
		else if (field->type == FT_SHORT)
			sprintf(temp,"\tshort %s;",field->name);
		else if (field->type == FT_INT)
			sprintf(temp,"\tint %s;",field->name);
		else if (field->type == FT_LONG)
			sprintf(temp,"\tlong %s;",field->name);
		else if (field->type == FT_QUAD)
			sprintf(temp,"\tlong long %s;",field->name);
		else if (field->type == FT_FLOAT)
			sprintf(temp,"\tfloat %s;",field->name);
		else if (field->type == FT_DOUBLE)
			sprintf(temp,"\tdouble %s;",field->name);
		else if (field->type == FT_LONGDBL)
			sprintf(temp,"\tlong double %s;",field->name);
		else if (field->type == FT_DATE)
			sprintf(temp,"\tchar %s[%d];",field->name, field->len+1);
		else
			sprintf(temp,"\tunknown %s;",field->name);
#endif
		dprintf("temp: %s\n", temp);

		/* Add the comment */
		if (strlen(field->comment)) {
			len = 8 + (strlen(temp) - 1);
			if ( (len % 8) != 0)
				offset = 8 - (len % 8);
			else
				offset = 8;
			while(len < 40) {
				strcat(temp,"\t");
				len += offset;
				offset = 8;
			}
			strcat(temp,"/* ");
			strcat(temp,field->comment);
			strcat(temp," */");
		}

		/* Write the line */
		fprintf(fp,"%s\n",temp);
	}
	fprintf(fp,"};\n");
#if 0
	fprintf(fp,"typedef struct %s_record %s_REC;\n",table->name,
		stredit(prefix,"UPCASE"));
	fprintf(fp,"#define %s_REC_SIZE sizeof(struct %s_record)\n",
		stredit(prefix,"UPCASE"),table->name);
#endif

	if (opts & OPT_RDT) {
		if (opts & OPT_DEBUG) printf("write_inc: writing rdt...\n");
		/* Write out the record descriptor table */
		offset = 0;
		fprintf(fp,"\n");
		fprintf(fp,"#ifdef NEED_%s_RDT\n",stredit(prefix,"UPCASE"));
		fprintf(fp,"/* Record Descriptor Table for %s */\n",
			table->name);
		fprintf(fp,"RDT %s_rdt[] = {\n",prefix);
		list_reset(table->fields);
		while( (field = list_get_next(table->fields)) != 0) {
			fprintf(fp,"\t{ \"%s\",",
				stredit(field->name,"UPCASE"));
			if (strlen(field->name) < 19)
				fprintf(fp,"\t");
			if (strlen(field->name) < 11)
				fprintf(fp,"\t");
			if (strlen(field->name) < 3)
				fprintf(fp,"\t");
			fprintf(fp,"%d,\t",offset);
#if 0
			switch(field->type) {
				case FT_CHAR:
					fprintf(fp,"%s,%d },\n",
						"DATA_TYPE_CHAR",field->len);
					offset+=field->len;
				break;
				case FT_STRING:
					fprintf(fp,"%s,%d },\n",
						"DATA_TYPE_STRING",field->len);
					offset+=field->len;
					break;
				case FT_SHORT:
					fprintf(fp,"%s,0 },\n",
						"DATA_TYPE_SHORT");
					offset+=2;
					break;
				case FT_LONG:
					fprintf(fp,"%s,0 },\n",
						"DATA_TYPE_LONG");
					offset+=4;
					break;
				case FT_DOUBLE:
					fprintf(fp,"%s,0 },\n",
						"DATA_TYPE_DOUBLE");
					offset+=8;
					break;
				case FT_LONGDBL:
					fprintf(fp,"%s,0 },\n",
						"DATA_TYPE_LONGDBL");
					offset+=16;
					break;
				case FT_DATE:
					fprintf(fp,"%s,21 },\n",
						"DATA_TYPE_STRING");
					offset+=21;
					break;
				default:
					fprintf(fp,"%s,0 },\n",
						"DATA_TYPE_UNKNOWN");
					break;
			}
#endif
		}
		fprintf(fp,"\t{ 0,%d,0,0 }\n",offset);
		fprintf(fp,"};\n");
		fprintf(fp,"#endif\n");
	}

#ifdef XXX
	if (opts & OPT_NET) {
		if (opts & OPT_DEBUG) printf("write_inc: writing net rec...\n");
		/* Write out the net rec structure definition */
		fprintf(fp,"\n");
		fprintf(fp,"/* Network record for %s */\n",table_name);
		fprintf(fp,"struct %s_net_record {\n",prefix);
		cur_field = field_list;
		while(cur_field) {
			if (cur_field->field_type == FT_CHAR) {
				fprintf(fp,"\tchar %s",cur_field->field_name);
				if (cur_field->field_len > 1)
					fprintf(fp,"[%d];\n",
						cur_field->field_len);
				else
					fprintf(fp,";\n");
			}
			else if (cur_field->field_type == FT_SHORT)
				fprintf(fp,"\tchar %s[5];\n",
					cur_field->field_name);
			else if (cur_field->field_type == FT_LONG)
				fprintf(fp,"\tchar %s[12];\n",
					cur_field->field_name);
			else if (cur_field->field_type == FT_DOUBLE)
				fprintf(fp,"\tchar %s[40];\n",
					cur_field->field_name);
			else if (cur_field->field_type == FT_LONGDBL)
				fprintf(fp,"\tchar %s[80];\n",
					cur_field->field_name);
			else if (cur_field->field_type == FT_DATE)
				fprintf(fp,"\tchar %s[21];\n",
					cur_field->field_name);
			else
				fprintf(fp,"\tunknown %s;\n",
					cur_field->field_name);
			cur_field = cur_field->next;
		}
		fprintf(fp,"};\n");
		fprintf(fp,"typedef struct %s_net_record %s_NET_REC;\n",prefix,
			stredit(prefix,"UPCASE"));
		fprintf(fp,
		    "#define %s_NET_REC_SIZE sizeof(struct %s_net_record)\n",
			stredit(prefix,"UPCASE"),prefix);
	}

	/* Write out the function declarations */
	if (opts & OPT_DEBUG) printf("write_inc: writing func decs:");
	fprintf(fp,"\n");
	fprintf(fp,"/* %s function declarations */\n",table->name);
	if (opts & OPT_PORT) {
		if (opts & OPT_DEBUG) printf(" open");
		fprintf(fp,"void open_%s_cursor(long *",prefix);
		if (key_list) {
			fprintf(fp,",");
			cur_key = key_list;
			while(cur_key) {
				fprintf(fp,"%s",cur_key->key_type);
				if (cur_key->is_ptr) fprintf(fp," *");
				if (cur_key->next) fprintf(fp,",");
				cur_key = cur_key->next;
			}
		}
		fprintf(fp,");\n");
		if (opts & OPT_DEBUG) printf(" fetch");
		fprintf(fp,"void fetch_%s_record(long *,%s_REC *);\n",
			prefix,stredit(prefix,"UPCASE"));
		if (opts & OPT_DEBUG) printf(" close");
		fprintf(fp,"void close_%s_cursor(long *);\n",prefix);
		if (strlen(seq_name)) {
			if (opts & OPT_DEBUG) printf(" get_id");
			fprintf(fp,"void get_%s_id(long *,%s *);\n",
				prefix,ID_TYPE_STRING);
		}
		if (opts & OPT_INS) {
			if (opts & OPT_DEBUG) printf(" insert");
			fprintf(fp,"void insert_%s_record(long *,%s_REC *);\n",
				prefix,stredit(prefix,"UPCASE"));
		}
	}
	else {
		if (opts & OPT_DEBUG) printf(" open");
		fprintf(fp,"int open_%s_cursor(",prefix);
		if (key_list) {
			cur_key = key_list;
			while(cur_key) {
				fprintf(fp,"%s",cur_key->key_type);
				if (cur_key->is_ptr) fprintf(fp," *");
				if (cur_key->next) fprintf(fp,",");
				cur_key = cur_key->next;
			}
		}
		else
			fprintf(fp,"void");
		fprintf(fp,");\n");
		if (opts & OPT_DEBUG) printf(" fetch");
		fprintf(fp,"int fetch_%s_record(%s_REC *);\n",
			prefix,stredit(prefix,"UPCASE"));
		if (opts & OPT_DEBUG) printf(" close");
		fprintf(fp,"int close_%s_cursor(void);\n",prefix);
		if (strlen(seq_name)) {
			if (opts & OPT_DEBUG) printf(" get_id");
			fprintf(fp,"int get_%s_id(%s *);\n",
				prefix,ID_TYPE_STRING);
		}
		if (opts & OPT_INS) {
			if (opts & OPT_DEBUG) printf(" insert");
			fprintf(fp,"int insert_%s_record(%s_REC *);\n",
				prefix,stredit(prefix,"UPCASE"));
		}
	}
	if (opts & OPT_DEBUG) printf(".\n");
#endif
	fprintf(fp,"\n#endif /* %s */\n",defname);

	/* Close the file and return */
	if (opts & OPT_DEBUG) printf("write_inc: done!\n");
	fclose(fp);
	return 0;
}
